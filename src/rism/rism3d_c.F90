!<compile=optimized>
! The 3D-RISM-KH software found here is copyright (c) 2010-2012 by
! Andriy Kovalenko, Tyler Luchko and David A. Case.
!
! This program is free software: you can redistribute it and/or modify it
! under the terms of the GNU General Public License as published by the Free
! Software Foundation, either version 3 of the License, or (at your option)
! any later version.
!
! This program is distributed in the hope that it will be useful, but
! WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
! for more details.
!
! You should have received a copy of the GNU General Public License in the
! ../../LICENSE file.  If not, see <http://www.gnu.org/licenses/>.
!
! Users of the 3D-RISM capability found here are requested to acknowledge
! use of the software in reports and publications.  Such acknowledgement
! should include the following citations:
!
! 1) A. Kovalenko and F. Hirata. J. Chem. Phys., 110:10095-10112  (1999);
! ibid. 112:10391-10417 (2000).
!
! 2) A. Kovalenko,  in:  Molecular  Theory  of  Solvation,  edited  by
! F. Hirata  (Kluwer Academic Publishers, Dordrecht, 2003), pp.169-275.
!
! 3) T. Luchko, S. Gusarov, D.R. Roe, C. Simmerling, D.A. Case, J. Tuszynski,
! and  A. Kovalenko, J. Chem. Theory Comput., 6:607-624 (2010).

#include "../include/dprec.fh"

!> 3D-RISM solver.
!! This defines the 3D-RISM type and associated subroutines.  All type
!! elements are public.  In general, read but do not write these
!! variables.  This provides an object-orientiented interface without
!! needing a function to access every variable.
!! Features of this solver include:
!! o Multiple closures w/ temperature derivatives: KH, HNC, PSE-n
!! o Temperature derivative expressed as T*d/dT
!! o MDIIS accelerated solutions
!! o Optional cutoffs
!! o Supercell method for long range asymptotics
!! o Analytic forces
!! o Variable grid size and dynamic memory allocation
!! o MPI support
!! o units:  energy       [kT]
!!           distances    [A]         (Angstroms)
!!           site charges [sqrt(kT A)]
!!           temperature  [K]
!!           density      [#/A^3]
!!           mass         [au]
!! o To convert [e] to [sqrt(kT A)] * sqrt(COULOMB_CONST_E/ KB / temperature)
module rism3d_c
  use rism3d_solute_c
  use rism3d_solvent_c
  use rism3d_potential_c
  use rism3d_grid_c
  use rism3d_closure_c
  use rism_report_c
  use rism_timer_c
  use mdiis_c
  use rism3d_fft_c

  use rism3d_opendx
#ifdef RISM3D_DEBUG
  !    use rism3d_debug_c
#endif
  implicit none
#include "def_time.h"

  type rism3d
     !! Solute/solvent information.

     !> Solute object.
     type(rism3d_solute) :: solute
     !> Solvent object.
     type(rism3d_solvent) :: solvent
     !> Potential object.
     type(rism3d_potential) :: potential
     !> Grid object.
     type(rism3d_grid) :: grid
     !> Closure object.
     type(rism3d_closure) :: closure

     !> List of closure names to use in order.  Only the last closure
     !! is used for thermodynamic output.  This can be used to
     !! progressively increase the order of the closure to aid
     !! convergence.
     character(len = 8), pointer :: closureList(:) => NULL()

     ! TIMERS.  Subtimers only account for computation.  We ignore setup etc.
     ! timer :: timer for this class.  Activated for all public routines
     ! resizeTimer :: time to resize solvent box
     ! reorientTimer :: time to reorient solute
     ! cuvpropTimer :: time to propagate Cuv solution
     ! fftTimer :: specifically times FFT calculation
     ! solveTimer :: specifically times rism1d_solve calculation
     ! solve3DRISMTimer :: specifically times solve3DRISM calculation
     ! single3DRISMsolutionTimer :: specifically times single3DRISMsolution calculation
     ! thermoTimer :: specifically times thermodynamics calculations
     ! forceTimer :: specifically times force calculation
     ! excessChemicalPotentialTimer :: specificall times excess chemical potential calculation
     type(rism_timer) :: timer, resizeTimer, reorientTimer, &
          cuvpropTimer, fftTimer, solventTimer, &
          solve3DRISMTimer, single3DRISMsolutionTimer, thermoTimer, &
          forceTimer, excessChemicalPotentialTimer

     !! private !(should be)

     ! FFTW options

     ! FFTW_ESTIMATE, FFTW_MEASURE, FFTW_PATIENT, FFTW_EXHAUSTIVE
     integer :: fftw_planner = FFT_ESTIMATE
     ! .true.  - use aligned memory and to enable SIMD;
     ! .false. - don't use aligned memory
     logical :: fft_aligned = .true.
     ! Transpose site number and spatial data locally before and after FFT.
     logical :: fftw_localtrans = .true.

     !> Output verbosity.  Useful for debugging.
     !! 0 - no ouput
     !! 1 - memory allocation and steps for convergence
     !! 2 - 1 + convergence progress
     integer :: verbose = 0

     ! This is a bit ugly and there may be a better solution.  We
     ! need to keep track of the number of solutions for both charged
     ! and un-charged solutes.  When we change between the solutes we
     ! set the nsolutions pointer to the appropriate variable.
     ! However, the 'target' attribute is not allowed in type
     ! definitions so these variables have to be pointers and we have
     ! to allocate memory for them.

     !> Number of times full solutions have been calculated.
     integer, pointer :: nsolution => NULL()
     !> Number of times full solutions with a charged solute have been
     !! calculated.
     integer, pointer :: nsolutionChg => NULL()
     !> Number of times full solutions with an uncharged solute have
     !! been calculated.
     integer, pointer :: nsolutionNoChg => NULL()

     !> Center the solute in the solvation box.
     !! 0 - off
     !! 1 - center of mass
     !! 2 - center of geometry
     !! 3 - center of mass shifted to the nearest grid point
     !! 4 - center of geometry shifted to the nearest grid point
     !! For negative numbers the centering translation is only
     !! calculated the for the first solution and used for subsequent
     !! calculations.  This allows the solute to drift in the box.
     integer :: centering = 1

     !> Number of past direct correlation function time step saves.
     integer :: ncuvsteps ! numDCFsteps

     !> Buffer distance to the edge of the box for the solvent. [A]
     _REAL_ :: buffer = 12d0
     !> Fixed box size for 3D-RISM.
     _REAL_ :: fixedBoxDimensionsR(3)
     !> Number of Cartesian grid points in each dimension for a fixed box size.
     integer :: fixedNumGridPoints(3)

     !> Variable box size.
     logical :: varbox = .true.

     !> long-range asymptotics k-space cut off tolerance.  Only grid
     !! points that have an approximate value greater than this will be computed.
     !! -1 - cutoff selected from calculation tolerance
     !! 0  - no cutoff applied
     !! >0 - used as the tolerance.  Should be a small value.  E.g., 1e-7
     _REAL_ :: asympKSpaceTolerance

     !> Lennard-Jones potential tolerance
     !! -1 - cutoff selected from calculation tolerance
     !! 0  - no cutoff applied
     !! >0 - used as the tolerance.  Should be a small value.  E.g., 1e-7
     _REAL_ :: ljTolerance
     
     !> Number of vectors used for MDIIS (consequently, the number of
     !! copies of CUV we need to keep for MDIIS).
     integer :: NVec
     !> MDIIS implementation to use.
     integer :: mdiis_method
     type(mdiis) :: mdiis_o

     !> 'Step size' for MDIIS.
     _REAL_ :: deloz = 0.7d0
     !> Restart threshold factor. Ratio of the current residual to the
     !! minimum residual in the basis that causes a restart.
     _REAL_ :: mdiis_restart

     !! MPI Support !!
     integer :: mpirank = 0, mpicomm = 0, mpisize = 1

     !! LARGE ARRAYS !!
     !
     ! all arrays are declared as pointers to ensure we can reallocate them as necessary
     !

     ! xvva       :: solvent chi interpolated for our grid size
     ! guv        :: solvent distribution function
     ! huv        :: guv - 1
     ! cuv        :: solvent direct correlation function and points to the
     !              current active solution in cuvWRK
     ! cuvres     :: residual value for cuv calculation and points to the
     !              current active solution in cuvresWRK.
     ! cuvWRK     :: Working Cuv memory.  Holds Cuv from previous iterations.
     ! cuvresWRK  :: Working Cuvres memory.  Holds Cuvres from previous iterations.
     ! oldcuv     :: previous solutions of cuv. Points to oldcuvChg
     !              or oldcuvNoChg depending on the charge state of the
     !              calculation.
     ! oldcuvChg  :: previous solutions for the standard charged system
     ! oldcuvNoChg :: previous solutions for the chargeless system.  This is only allocated
     !                if _unsetCharges() is called
     ! electronMap :: smeared solvent electron density map.
     _REAL_, pointer :: xvva(:) => NULL(), &
          oldcuv(:, :, :, :, :) => NULL(), &
          oldcuvChg(:, :, :, :, :) => NULL(), &
          oldcuvNoChg(:, :, :, :, :) => NULL(), &
          cuv(:, :, :, :) => NULL(), cuvWRK(:, :, :, :, :) => NULL(), &
          cuvres(:, :) => NULL(), cuvresWRK(:, :, :) => NULL()


     _REAL_, pointer :: guv(:, :) => NULL(), huv(:, :) => NULL()

     _REAL_, pointer :: electronMap(:, :, :) => NULL()

     ! cuvk        :: k-space Cuv solution from 3D-RISM
     !               solution. NOTE: we should consider using Huv or
     !               Guv memory instead.  However, it has to be
     !               checked first that it is not used for any thermodynamics calculations

     _REAL_, pointer :: cuvk(:, :) => NULL()

     ! fft :: fft object for standard 3D-RISM solution
     type(rism3d_fft) :: fft

     !> If true, a periodic 3D-RISM calculation is performed. This
     !! primarily differs from infinite dilution 3D-RISM by using
     !! Ewald sum potential in place of Coulombic potential and
     !! invoking the minimum image convention while calculating both
     !! the Ewald sum and Lennard-Jones potentials.
     logical :: periodic = .false.

     !> Lengths and interior angles of the unit cell. For aperiodic
     !! systems, the interior angles are always 90 degrees.
     _REAL_ :: unitCellDimensions(6)
     
     !> The abbreviated label of the periodic potential function used
     !! for periodic calculations. See rism3d_potential for valid values.
     character(len=255) :: periodicPotential = ""

  end type rism3d

  public :: rism3d_new, rism3d_destroy, rism3d_calculateSolution, rism3d_force, &
       rism3d_excessChemicalPotential_tot, rism3d_excessChemicalPotential, &
       rism3d_setbox_fixed, &
       rism3d_setclosure, rism3d_setverbosity, rism3d_setcut, rism3d_setmdiis

  private :: resizeBox, reallocateBox, &
       interpolateSolventSusceptibility, &
       solve3DRISM, single3DRISMsolution,  &
       guessDCF, updateDCFguessHistory

contains


  !> Constructor - precalculates the solute solvent terms that are not
  !! configuration dependent and sets box parameters.
  !!
  !! The solvation box may be fixed size or variable.  For fixed size,
  !! define o_boxlen and o_ng3.  For variable box size, define buffer
  !! and grdspc.  Do not mix these parameters as this will cause the
  !! program to halt.
  !!
  !! For periodic simulations, buffer can be set but will be ignored;
  !! (this should get fixed).  The unit cell parameters give the size of
  !! the box, and the grdspc(1:3) array gives an approximate grid
  !! spacing.  The actual spacing will be set that an exact number of 
  !! grids spans the box, and so that the number of grid points is even.  
  !! (In addtion, for MPI runs, the number of grids along y and z will 
  !! be adjusted to be a multiple of the number of MPI threads.)
  !!
  !! If this is an MPI run, supply the MPI communicator.  Only the rank
  !! 0 parameters will be used. However, due to the limitations of
  !! pre-Fortran2003, the closure must be the same length on all
  !! processes. The values and number of elements for the closure list
  !! on non-rank 0 processes still do not matter.
  !!
  !! Note that ljTolerance, tolerance, buffer, and solvBox are related
  !!
  !! Case 1: if ljtolerance==0, then compute the LJ interation
  !!     without cutoff
  !! Case 2: if ljtolerance<0 and buffer!=0, fit the LJ cutoff to fit
  !!     inside the solvent box so a correction may be applied
  !! Case 3: if ljtolerance<0 and buffer==0, select the ljtolerance <
  !!     tolerance but >0 and set buffer large enough to fit the cutoff
  !! Case 4: if ljtolerance>0 and buffer==0, set buffer large enough
  !!     to fit the cutoff
  !! Case 5: if ljtolerance > 0 and buffer != 0, use ljtolerance as
  !!     is.  Cutoff correction may not be applied.
  !!
  !! IN:
  !!   this :: new rism3d object
  !!   solu :: 3D-RISM solute object
  !!   solv :: 3D-RISM solvent object
  !!   centering :: center the solute in the solvation box.
  !!   ncuvsteps :: number of past cuv time steps saves
  !!   closure :: list of closures. Closures may be KH, HNC or PSEn
  !!              where n is an integer. Ensure the length attribute is
  !!              the same on all processes.
  !!   cut     :: distance cutoff for potential and force calculations, periodic calculations only
  !!   mdiis_nvec :: number of MDIIS vectors (previous iterations) to keep
  !!   mdiis_del :: scaling factor (step size) applied to estimated gradient (residual)
  !!   mdiis_method :: which implementation of the algorithm
  !!   treeDCF :: perform treecode DCF
  !!   treeTCF :: perform treecode TCF
  !!   treeCoulomb :: perform treecode Coulomb potential
  !!   treeDCFMAC :: treecode multipole acceptance parameter for DCF
  !!   treeTCFMAC :: treecode multipole acceptance parameter for TCF
  !!   treeCoulombMAC :: treecode multipole acceptance parameter for Coulomb
  !!   treeDCFOrder :: treecode order parameter for DCF
  !!   treeTCFOrder :: treecode order parameter for TCF
  !!   treeCoulombOrder :: treecode order parameter for Coulomb
  !!   treeDCFN0 :: treecode maximum leaf size parameter for DCF
  !!   treeTCFN0 :: treecode maximum leaf size parameter for TCF
  !!   treeCoulombN0 :: treecode maximum leaf size parameter for Coulomb
  !!   asympKSpaceTolerance :: long-range asymptotics k-space cut off
  !!       tolerance.  Only grid points that have an approximate value
  !!       greater than this will be computed.
  !!       -1 - cutoff selected from calculation tolerance
  !!       0  - no cutoff applied
  !!       >0 - used as the tolerance.  Should be a small value.  E.g., 1e-7
  !!   ljTolerance :: Lennard-Jones potential tolerance.  Only grid
  !!       points that have an approximate value greater than this
  !!       will be computed.
  !!       -1 - cutoff selected from calculation tolerance
  !!       0  - no cutoff applied
  !!       >0 - used as the tolerance.  Should be a small value.  E.g., 1e-7
  !!   chargeSmear :: Charge smearing parameter for long-range
  !!       asymtotics and Ewald, typically eta in the literature
  !!   o_buffer :: (optional) shortest distance between solute and solvent box boundary
  !!   o_grdspc :: (optional) linear grid spacing for the solvent box in each dimension
  !!   o_boxlen :: (optional) solvent box size in each dimension [A]
  !!   o_ng3    :: (optional) number of grid points in each dimension
  !!   o_mpicomm :: (optional) MPI communicator
  !!   o_periodic :: (optional) periodic electric potential to use, if any
  !!   o_unitCellDimensions :: (optional) geometry of the system unit cell

  subroutine rism3d_new(this, solute, solvent, centering, ncuvsteps, &
       closure, cut, mdiis_nvec, mdiis_del, mdiis_method, mdiis_restart, &
       treeDCF, treeTCF, treeCoulomb, &
       treeDCFMAC, treeTCFMAC, treeCoulombMAC, &
       treeDCFOrder, treeTCFOrder, treeCoulombOrder, &
       treeDCFN0, treeTCFN0, treeCoulombN0, &
       asympKSpaceTolerance, ljTolerance, chargeSmear, &
       o_buffer, o_grdspc, o_boxlen, o_ng3, o_mpicomm, &
       o_periodic, o_unitCellDimensions, o_biasPotential)
    use rism3d_solute_c
    use rism3d_solvent_c
    use safemem
    implicit none
#ifdef MPI
    include 'mpif.h'
#endif /*MPI*/
    type(rism3d), intent(inout) :: this
    type(rism3d_solute), intent(in), target :: solute
    type(rism3d_solvent), intent(in), target :: solvent
    integer, intent(in) :: centering, ncuvsteps
    character(len = *), intent(in) :: closure(:)
    _REAL_, intent(in) :: cut
    integer, intent(in) :: mdiis_nvec, mdiis_method
    _REAL_, intent(in) :: mdiis_del, mdiis_restart
    _REAL_, optional, intent(in) :: o_buffer, o_grdspc(3)
    _REAL_, optional, intent(in) :: o_boxlen(3)
    integer, optional, intent(in) :: o_ng3(3)
    integer, optional, intent(in) :: o_mpicomm
    character(len = *), optional, intent(in) :: o_periodic
    _REAL_, optional, intent(in) :: o_unitCellDimensions(6)
    _REAL_, optional, intent(in) :: o_biasPotential
    logical, intent(in) :: treeDCF
    logical, intent(in) :: treeTCF
    logical, intent(in) :: treeCoulomb
    _REAL_, intent(in) :: treeDCFMAC
    _REAL_, intent(in) :: treeTCFMAC
    _REAL_, intent(in) :: treeCoulombMAC
    integer, intent(in) :: treeDCFOrder
    integer, intent(in) :: treeTCFOrder
    integer, intent(in) :: treeCoulombOrder
    integer, intent(in) :: treeDCFN0
    integer, intent(in) :: treeTCFN0
    integer, intent(in) :: treeCoulombN0
    _REAL_, intent(in) :: asympKSpaceTolerance
    _REAL_, intent(in) :: ljTolerance
    _REAL_, intent(in) :: chargeSmear
    ! temporary copies
    character(len = len(closure)), pointer :: t_closure(:)
    _REAL_ :: t_cut
    integer :: t_mdiis_nvec, t_mdiis_method
    _REAL_ :: t_mdiis_del, t_mdiis_restart
    _REAL_ :: t_buffer, t_grdspc(3)
    _REAL_ :: t_boxlen(3)
    integer :: t_ng3(3)
    _REAL_ :: t_unitCellDimensions(6)
    integer :: t_mpicomm
    logical :: t_treeDCF
    logical :: t_treeTCF
    logical :: t_treeCoulomb
    _REAL_ :: t_treeDCFMAC
    _REAL_ :: t_treeTCFMAC
    _REAL_ :: t_treeCoulombMAC
    integer :: t_treeDCFOrder
    integer :: t_treeTCFOrder
    integer :: t_treeCoulombOrder
    integer :: t_treeDCFN0
    integer :: t_treeTCFN0
    integer :: t_treeCoulombN0
    _REAL_ :: t_asympKSpaceTolerance
    _REAL_ :: t_ljTolerance
    _REAL_ :: t_chargeSmear
    integer :: nclosure
    integer :: err

    ! MPI set up starts by obtaining rank and size.  Temporary copies
    ! of input parameters that do not directly set object variables
    ! are made.  These are they broadcast to the rank > 0 processes.
    ! Then all processes complete the intitialization procedure
    ! using the temporary copies.  This leaves the input parameters
    ! untouched.

    call rism_timer_new(this%timer, "3D-RISM")
    call rism_timer_start(this%timer)
    call rism_timer_new(this%thermoTimer, "Thermodynamics")
    call rism_timer_setParent(this%thermoTimer, this%timer)
    call rism_timer_new(this%forceTimer, "Force")
    call rism_timer_setParent(this%forceTimer, this%thermoTimer)
    call rism_timer_new(this%excessChemicalPotentialTimer, "Excess Chemical Potential")
    call rism_timer_setParent(this%excessChemicalPotentialTimer, this%thermoTimer)
    call rism_timer_new(this%solventTimer, "Solve 3D-RISM")
    call rism_timer_setParent(this%solventTimer, this%timer)
    call rism_timer_new(this%resizeTimer, "Solvation box resize")
    call rism_timer_setParent(this%resizeTimer, this%solventTimer)
    call rism_timer_new(this%reorientTimer, "Solute reorientation")
    call rism_timer_setParent(this%reorientTimer, this%solventTimer)
    call rism_timer_new(this%cuvpropTimer, "Cuv propagation")
    call rism_timer_setParent(this%cuvpropTimer, this%solventTimer)
    call rism_timer_new(this%solve3DRISMTimer, "RXRISM")
    call rism_timer_setParent(this%solve3DRISMTimer, this%solventTimer)
    call rism_timer_new(this%single3DRISMsolutionTimer, "R1RISM")
    call rism_timer_setParent(this%single3DRISMsolutionTimer, this%solve3DRISMTimer)
    call rism_timer_new(this%fftTimer, "FFT")
    call rism_timer_setParent(this%fftTimer, this%single3DRISMsolutionTimer)

    nullify(t_closure)

    if (present(o_periodic)) then
       if (o_periodic /= '') then
          this%periodic = .true.
          this%periodicPotential = o_periodic
       end if
    end if

    ! GET RANK AND SIZE
    this%mpicomm = 0
    this%mpisize = 1
    this%mpirank = 0
#ifdef MPI
    if (present(o_mpicomm)) then
       this%mpicomm = o_mpicomm
       if (this%mpicomm == MPI_COMM_NULL) &
            call rism_report_error("RISM3D: received NULL MPI communicator")
       call mpi_comm_rank(this%mpicomm, this%mpirank, err)
       if (err /= 0) call rism_report_error &
            ("(a,i8)", "RISM3D: could not get MPI rank for communicator ", this%mpicomm)
       call mpi_comm_size(this%mpicomm, this%mpisize, err)
       if (err /= 0) call rism_report_error &
            ("(a,i8)", "RISM3D: could not get MPI size for communicator ", this%mpicomm)
       call rism_report_mpi(this%mpicomm)
    end if
#endif /*MPI*/
    ! MAKE TEMPORARY COPIES
    if (this%mpirank == 0) then

       call rism3d_solute_clone(solute, this%solute)
       call rism3d_solvent_clone(solvent, this%solvent)
       this%centering = centering
       ! Enforcing no centering when periodic.
       if (this%periodic) this%centering = 0
       this%ncuvsteps = ncuvsteps
       nclosure = size(closure)
       t_closure => safemem_realloc(t_closure, len(closure), nclosure)
       t_closure = closure
       t_cut = cut
       t_mdiis_nvec = mdiis_nvec
       t_mdiis_method = mdiis_method
       t_mdiis_del = mdiis_del
       t_mdiis_restart = mdiis_restart
       ! check box parameters
       if (present(o_buffer) .and. present(o_grdspc)) then
              !! (This branch should also be taken for periodic RISM)
          t_buffer = o_buffer
          t_grdspc = o_grdspc
          if (present(o_boxlen) .or. present(o_ng3)) &
               call rism_report_error("RISM3D: do not set BOXLEN or NG3 for variable box size")
       else if (present(o_boxlen) .and. present(o_ng3)) then
          t_boxlen = o_boxlen
          t_ng3 = o_ng3
          if (present(o_buffer) .or. present(o_grdspc)) &
               call rism_report_error("RISM3D: do not set BUFFER or GRDSPC for fixed box size")
       else
          call rism_report_error("RISM3D: not enough parameters for fixed or variable box size")
       end if
       if (present(o_unitCellDimensions)) then
          t_unitCellDimensions = o_unitCellDimensions
       end if
       t_treeDCF = treeDCF
       t_treeTCF = treeTCF
       t_treeCoulomb = treeCoulomb
       t_treeDCFMAC = treeDCFMAC
       t_treeTCFMAC = treeTCFMAC
       t_treeCoulombMAC = treeCoulombMAC
       t_treeDCFOrder = treeDCFOrder
       t_treeTCFOrder = treeTCFOrder
       t_treeCoulombOrder = treeCoulombOrder
       t_treeDCFN0 = treeDCFN0
       t_treeTCFN0 = treeTCFN0
       t_treeCoulombN0 = treeCoulombN0
       t_asympKSpaceTolerance = asympKSpaceTolerance
       t_ljTolerance = ljTolerance
       t_chargeSmear = chargeSmear
    end if
#ifdef MPI
    ! BROADCAST PARAMETERS
    ! set solu on all processes
    call rism3d_solute_mpi_clone(this%solute, this%mpirank, this%mpicomm)
    ! set solv on all processes
    call rism3d_solvent_mpi_clone(this%solvent, this%mpirank, this%mpicomm)
    ! set centering on all processes
    call mpi_bcast(this%centering, 1, mpi_integer, 0, this%mpicomm, err)
    if (err /= 0) call rism_report_error("RISM3D: broadcast CENTERING in constructor failed")
    ! set ncuvstpes on all processes
    call mpi_bcast(this%ncuvsteps, 1, mpi_integer, 0, this%mpicomm, err)
    if (err /= 0) call rism_report_error("RISM3D: broadcast NCUVSTEPS in constructor failed")
    call mpi_bcast(nclosure, 1, mpi_integer, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error &
         ("RISM3D interface: could not broadcast PROGRESS")
    if (this%mpirank/=0) &
         t_closure => safemem_realloc(t_closure, len(t_closure), nclosure)
    call mpi_bcast(t_closure, len(t_closure) * nclosure, mpi_character, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast CLOSURE in constructor failed")
    call mpi_bcast(t_cut, 1, mpi_double_precision, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast CUT in constructor failed")
    call mpi_bcast(t_mdiis_nvec, 1, mpi_integer, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast MDIIS_NVEC in constructor failed")
    call mpi_bcast(t_mdiis_del, 1, mpi_double_precision, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast MDIIS_DEL in constructor failed")
    call mpi_bcast(t_mdiis_restart, 1, mpi_double_precision, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast MDIIS_RESTART in constructor failed")
    call mpi_bcast(t_mdiis_method, 1, mpi_integer, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast MDIIS_METHOD in constructor failed")
    if (present(o_buffer) .and. present(o_grdspc)) then
       call mpi_bcast(t_buffer, 1, mpi_double_precision, 0, this%mpicomm, err)
       if (err /=0) call rism_report_error("RISM3D: broadcast BUFFER in constructor failed")
       call mpi_bcast(t_grdspc, 3, mpi_double_precision, 0, this%mpicomm, err)
       if (err /=0) call rism_report_error("RISM3D: broadcast GRDSPC in constructor failed")
    else
       call mpi_bcast(t_boxlen, 3, mpi_double_precision, 0, this%mpicomm, err)
       if (err /=0) call rism_report_error("RISM3D: broadcast BOXLEN in constructor failed")
       call mpi_bcast(t_ng3, 3, mpi_integer, 0, this%mpicomm, err)
       if (err /=0) call rism_report_error("RISM3D: broadcast NG3 in constructor failed")
    end if
    if (present(o_unitCellDimensions)) then
       call mpi_bcast(t_unitCellDimensions, 6, mpi_double_precision, 0, this%mpicomm, err)
       if (err /=0) call rism_report_error("RISM3D: broadcast UNITCELLDIMENSIONS in constructor failed")
    end if
    call mpi_bcast(t_treeDCF, 1, mpi_logical, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast treeDCF in constructor failed")
    call mpi_bcast(t_treeTCF, 1, mpi_logical, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast treeTCF in constructor failed")
    call mpi_bcast(t_treeCoulomb, 1, mpi_logical, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast treeCoulomb in constructor failed")
    call mpi_bcast(t_treeDCFMAC, 1, mpi_double, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast treeDCFMAC in constructor failed")
    call mpi_bcast(t_treeTCFMAC, 1, mpi_double, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast treeTCFMAC in constructor failed")
    call mpi_bcast(t_treeCoulombMAC, 1, mpi_double, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast treeCoulombMAC in constructor failed")
    call mpi_bcast(t_treeDCFOrder, 1, mpi_integer, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast treeDCFOrder in constructor failed")
    call mpi_bcast(t_treeTCFOrder, 1, mpi_integer, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast treeTCFOrder in constructor failed")
    call mpi_bcast(t_treeCoulombOrder, 1, mpi_integer, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast treeCoulombOrder in constructor failed")
    call mpi_bcast(t_treeDCFN0, 1, mpi_integer, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast treeDCFN0 in constructor failed")
    call mpi_bcast(t_treeTCFN0, 1, mpi_integer, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast treeTCFN0 in constructor failed")
    call mpi_bcast(t_treeCoulombN0, 1, mpi_integer, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast treeCoulombN0 in constructor failed")
    call mpi_bcast(t_asympKSpaceTolerance, 1, mpi_double, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast asympKSpaceTolerance in constructor failed")
    call mpi_bcast(t_ljTolerance, 1, mpi_double, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast ljTolerance in constructor failed")
    call mpi_bcast(t_chargeSmear, 1, mpi_double, 0, this%mpicomm, err)
    if (err /=0) call rism_report_error("RISM3D: broadcast chargeSmear in constructor failed")
#endif /*MPI*/
    ! INITIALIZE
    call rism3d_grid_new(this%grid, this%mpicomm)
    call rism_timer_stop(this%timer)
    call rism3d_setmdiis(this, t_mdiis_nvec, t_mdiis_del, t_mdiis_method, t_mdiis_restart)
    call rism_timer_start(this%timer)
    call rism3d_potential_new(this%potential, this%grid, this%solvent, this%solute, 0d0, &
         this%fft, this%periodicPotential, o_biasPotential,&
         t_treeDCF, t_treeTCF, t_treeCoulomb, t_treeDCFMAC, t_treeTCFMAC, &
         t_treeCoulombMAC, t_treeDCFOrder, t_treeTCFOrder, t_treeCoulombOrder, &
         t_treeDCFN0, t_treeTCFN0, t_treeCoulombN0, chargeSmear)
    call rism3d_potential_setTimerParent(this%potential, this%solventTimer)

#ifdef MPI
    call mdiis_new_mpi(this%mdiis_o, this%mdiis_method, &
         this%deloz, 0d0, &
         this%MDIIS_restart, &
         this%mpirank, this%mpisize, this%mpicomm)
#else
    call mdiis_new(this%mdiis_o, this%mdiis_method, &
         this%deloz, 0d0, &
         this%MDIIS_restart)
#endif /*MPI*/

    call mdiis_setTimerParent(this%mdiis_o, this%single3DRISMsolutiontimer)
    call rism_timer_stop(this%timer)
    call rism3d_setcut(this, t_cut)
    call rism3d_setclosurelist(this, t_closure)
    call rism3d_setbox_fixed(this, t_boxlen, t_ng3)

    if (present(o_unitCellDimensions)) then
       !TODO: This can probably be made a local variable.
       this%unitCellDimensions = t_unitCellDimensions
       call rism3d_grid_setUnitCellDimensions(this%grid, this%unitCellDimensions, this%periodic)
    end if

    allocate(this%nsolutionChg, this%nsolutionNoChg)
    this%nsolutionChg = 0
    this%nsolutionNoChg = 0
    this%nsolution => this%nsolutionChg

    this%asympKSpaceTolerance = t_asympKSpaceTolerance
    this%ljTolerance = t_ljTolerance
    
    call rism3d_fft_global_init()
    this%fftw_planner = FFT_MEASURE
#if defined(MPI)
    this%fft_aligned = .false.
#else
    this%fft_aligned = .true.
#endif
    this%fftw_localtrans = .true.

    ! Clean up locally allocated temporary memory.
    if (safemem_dealloc(t_closure) /= 0) &
         call rism_report_error("RISM3D:NEW: failed to deallocate t_closure")
#ifdef RISM3D_DEBUG
    call rism3d_debug_new(this%grid, this%solvent, this%mpirank, this%mpisize, this%mpicomm)
#endif

  end subroutine rism3d_new

  !> Check if we can calculate molecular reconstructions
  !! IN:
  !!   this : rism3d object
  !! OUT:
  !!    .true. if we can, .false. if we can't
  function rism3d_canCalc_molReconstruct(this) result(can_molReconstruct)
    implicit none
    type(rism3d), intent(in) :: this
    logical :: can_molReconstruct
    can_molReconstruct = rism3d_solvent_canCalc_molReconstruct(this%solvent)
  end function rism3d_canCalc_molReconstruct

  !> Set parent for this timer
  !! IN:
  !!   this : rism3d object
  !!   parent : parent timer object
  subroutine rism3d_setTimerParent(this, parent)
    implicit none
    type(rism3d), intent(inout) :: this
    type(rism_timer), intent(inout) :: parent
    call rism_timer_start(this%timer)
    call rism_timer_setParent(this%timer, parent)
    call rism_timer_stop(this%timer)
  end subroutine rism3d_setTimerParent

  !>Sets the parameters for a fixed solvation box.
  !! IN:
  !!  this :: rism3d object
  !!  boxlen :: solvent box size in each dimension in Angstroms
  !!  ng3    :: number of grid points in each dimension
  subroutine rism3d_setbox_fixed(this, boxlen, ng3)
    implicit none
    type(rism3d), intent(inout) :: this
    _REAL_, intent(in) :: boxlen(3)
    integer, intent(in) :: ng3(3)
    call rism_timer_start(this%timer)
    this%varbox = .false.
    this%fixedBoxDimensionsR = boxlen
    this%fixedNumGridPoints = ng3
    call rism_timer_stop(this%timer)
  end subroutine rism3d_setbox_fixed


  !> Sets the closure list and sets the current closure to the first one
  !! in the list.  When there is no previous solution to work from, the
  !! solver will use each closure in the list in turn. By choosing the
  !! list to increase in order, it makes it possible to converge
  !! otherwise difficult closures. Only the last closure is used for
  !! thermodynamic output.
  !! IN:
  !!   this :: rism3d object
  !!   closure :: array of closure types (see closure enumeration).
  subroutine rism3d_setclosurelist(this, closure)
    implicit none
    type(rism3d), intent(inout) :: this
    character(len = *), intent(in) :: closure(:)
    call rism_timer_start(this%timer)
    this%closureList => safemem_realloc(this%closureList, len(this%closureList), &
         ubound(closure, 1))
    this%closureList = closure
    call rism_timer_stop(this%timer)
    call rism3d_setclosure(this, this%closureList(1))
  end subroutine rism3d_setclosurelist


  !> Sets the closure type.
  !! IN:
  !!   this :: rism3d object
  !!   closure :: closure type (see closure enumeration).
  subroutine rism3d_setclosure(this, closure)
    implicit none
    type(rism3d), intent(inout) :: this
    character(len = *), intent(in) :: closure
    call rism_timer_start(this%timer)
    call rism3d_closure_destroy(this%closure)
    call rism3d_closure_new(this%closure, closure, this%potential)
    call rism_timer_stop(this%timer)
  end subroutine rism3d_setclosure


  !> Sets verbosity of output.
  !! IN:
  !!   this :: rism3d object
  !!   verbosity :: 0 - no output
  !!                1 - memory allocation and steps for convergence
  !!                2 - 1 + convergence progress
  subroutine rism3d_setverbosity(this, verbosity)
    implicit none
    type(rism3d), intent(inout) :: this
    integer, intent(in) :: verbosity
    call rism_timer_start(this%timer)
    this%verbose = verbosity
    call rism_timer_stop(this%timer)
  end subroutine rism3d_setverbosity


  !> Sets the cut off distance for periodic potential and force calculations.
  !! IN:
  !!   this :: rism3d object
  !!   cut     :: distance cutoff for potential and force calculations
  subroutine rism3d_setcut(this, cut)
    implicit none
    type(rism3d), intent(inout) :: this
    _REAL_, intent(in) :: cut
    call rism_timer_start(this%timer)
    call rism3d_potential_setCut_ljdistance(this%potential, cut)
    call rism_timer_stop(this%timer)
  end subroutine rism3d_setcut


  !> Sets MDIIS parameters
  !! IN:
  !!   this :: rism3d object!
  !!   nvec :: number of MDIIS vectors (previous iterations) to keep
  !!   del :: scaling factor (step size) applied to estimated gradient (residual)
  !!   method :: which implementation of the algorithm
  !!   restart :: restart threshold factor. Ratio of the current residual to the
  !!              minimum residual in the basis that causes a restart
  subroutine rism3d_setmdiis(this, nvec, del, method, restart)
    implicit none
    type(rism3d), intent(inout) :: this
    integer, intent(in) :: nvec, method
    _REAL_, intent(in) :: del, restart
    call rism_timer_start(this%timer)
    this%NVec = nvec
    this%deloz = del
    this%mdiis_method = method
    this%mdiis_restart = restart
    call rism_timer_stop(this%timer)
  end subroutine rism3d_setmdiis


  !> Sets solute coordinates.
  !! IN:
  !!   this :: rism3d object
  !!   ratu :: coordinates
  subroutine rism3d_setCoord(this, solutePositions)
    implicit none
    type(rism3d), intent(inout) :: this
    _REAL_, intent(in) :: solutePositions(:, :)
    call rism_timer_start(this%timer)
    call rism3d_solute_setCoord(this%solute, solutePositions)
    call rism_timer_stop(this%timer)
  end subroutine rism3d_setCoord


  !> Sets all solute partial charges to zero, resets MDIIS and wipes out
  !! working memory.
  !! IN:
  !!   this :: rism3d object
  subroutine rism3d_unsetCharges(this)
    implicit none
    type(rism3d), intent(inout) :: this
    integer :: i
    ! reset MDIIS.  This makes the working vector index 1
    call mdiis_reset(this%mdiis_o)
    this%cuv => this%cuvWRK(:, :, :, :, mdiis_getWorkVector(this%mdiis_o))
    this%cuvres => this%cuvresWRK(:, :, mdiis_getWorkVector(this%mdiis_o))
    ! turn off charges
    call rism3d_solute_unsetCharges(this%solute)
    ! Use the number of no charge solutions
    this%nsolution => this%nsolutionNoChg
    ! Use no charge previous soluitions
    this%oldcuv => this%oldcuvNoChg
    ! Attempt to restore last solution without charge here.  If this
    ! fails, attempt again at the end of reallocateBox
    if (this%nsolutionNoChg > 0) then
       if (all(ubound(this%oldcuv(:,:,:,:,1)) .eq. ubound(this%cuv))) then
          call dcopy(product(ubound(this%cuv)), this%oldcuv, 1,this%cuv, 1)
       end if
    end if
  end subroutine rism3d_unsetCharges


  !> Sets all solute partial charges to to their original
  !! values. (Undoes rism3d_unsetCharge().)
  !! IN:
  !!   this :: rism3d object
  subroutine rism3d_resetCharges(this)
    implicit none
    type(rism3d), intent(inout) :: this
    integer :: i
    ! reset MDIIS.  This makes the working vector index 1
    call mdiis_reset(this%mdiis_o)
    this%cuv => this%cuvWRK(:, :, :, :, mdiis_getWorkVector(this%mdiis_o))
    this%cuvres => this%cuvresWRK(:, :, mdiis_getWorkVector(this%mdiis_o))
    ! get back the charges
    call rism3d_solute_resetCharges(this%solute)
    ! restore the number of previous solutions
    this%nsolution => this%nsolutionChg
    ! point to previous charged solutions
    this%oldcuv => this%oldcuvChg
    ! Attempt to restore last solution with charge here.  If this
    ! fails, attempt again at the end of reallocateBox
    if (this%nsolutionNoChg > 0) then
       if (all(ubound(this%oldcuv(:,:,:,:,1)) .eq. ubound(this%cuv))) then
          call dcopy(product(ubound(this%cuv)), this%oldcuv, 1,this%cuv, 1)
       end if
    end if
  end subroutine rism3d_resetCharges


  !> Calculates the full 3D-RISM solvent distribution.  This is required to
  !! calculate thermodynamic quantities.
  !! @param[in,out] this rism3d object.
  !! @param[in,out] ksave Save intermediate results every ksave
  !!            interations (0 means no saves).
  !! @param[in] kshow Print parameter for relaxation steps every kshow
  !!            iteration (0 means no print).
  !! @param[in] maxSteps Maximum number of rism relaxation steps.
  !! @param[in] tolerance Convergence tolerances. There should be one
  !!          tolerance per closure in the closure list.
  subroutine rism3d_calculateSolution(this, ksave, kshow, maxSteps, tolerance)
    use constants, only : pi
    implicit none
#if defined(MPI)
    include 'mpif.h'
#endif /*defined(MPI)*/
    type(rism3d), intent(inout) :: this
    integer, intent(in) :: ksave, kshow, maxSteps
    _REAL_, intent(in) :: tolerance(:)

    _REAL_ :: asympKSpaceTolerance
    _REAL_ :: ljTolerance, com(3)
    ! iclosure :: counter for closures
    integer :: iclosure

    _REAL_ :: offset(3), buffer(3)
    integer :: id, iu

    call rism_timer_start(this%solventTimer)

    ! 0) Quick check that the tolerance list is of the correct length.
    if (ubound(tolerance, 1) /= ubound(this%closureList, 1)) &
         call rism_report_error("(a,i3,a,i3)", &
         "RISM3D_SOLVE: number of tolerances, ", &
         ubound(tolerance, 1), ", is not equal to numer of closures, ", &
         ubound(this%closureList, 1))

    ! 1) Reorient solute along the principal axis and resize the grids
    ! if necessary.

    ! 2a) Set tolerances for LJ potential and long range asymptotics
    ! asympKSpaceTolerance
    ! Case 1: use the  asympKSpaceTolerance as is
    ! Case 2: if asympKSpaceTolerance < 0, select the asympKSpaceTolerance < tolerance
    ! Case 3: if asympKSpaceTolerance > 0, use the asympKSpaceTolerance
    if (this%asympKSpaceTolerance <0d0) then
       asympKSpaceTolerance = tolerance(size(tolerance))/10
    else
       asympKSpaceTolerance = this%asympKSpaceTolerance
    end if

    ! k-space asymptotics cutoff depends on the box size and is called
    ! in resizeBox()
        
    ! 2b) Get the minimum box size for this frame.
    ! DAC: don't redo the box size stuff all the time for periodic?
    !  old:   if (this%periodic .or. this%varbox .or. this%nsolution == 0) then
    if (this%varbox .or. this%nsolution == 0) then
       call rism_timer_start(this%resizeTimer)
       call timer_start(TIME_RESIZE)
       call resizeBox(this)
       call timer_stop(TIME_RESIZE)
       call rism_timer_stop(this%resizeTimer)
    end if

    if (this%verbose>=0) then
       call rism_report_message("||Setting solvation box to")
       call rism_report_message("(3(a,i10))", "|grid size: ", &
            this%grid%globalDimsR(1), " X ", this%grid%globalDimsR(2), " X ", this%grid%globalDimsR(3))
       call rism_report_message("(3(a,f10.3))", "|box size [A]:  ", &
            this%grid%boxLength(1), " X ", this%grid%boxLength(2), " X ", this%grid%boxLength(3))
       call rism_report_message("(3(a,f10.3))", "|grid spacing [A]: ", &
            this%grid%spacing(1), " X ", this%grid%spacing(2), " X ", this%grid%spacing(3))
       call rism_report_message("(3(a,f10.3))", "|internal angles [Â°]:  ", &
            this%grid%unitCellAngles(1) * 180 / pi, ", ", &
            this%grid%unitCellAngles(2) * 180 / pi, ", ", &
            this%grid%unitCellAngles(3) * 180 / pi)
       call rism_report_message("(a,f10.3)", "|inscribed sphere radius [A]: ", &
            this%grid%inscribedSphereRadius)
       call flush(rism_report_getmunit())
    end if
    
    ! 3) Calculate electrostatic and Lennard-Jones potential about the
    ! solute.
    call rism3d_potential_calc(this%potential,ljTolerance)


    ! 4) Propagate previously saved solute-solvent DCF solutions to
    ! create an initial guess for this solution.
    call timer_start(TIME_CUVPROP)
    call rism_timer_start(this%cuvpropTimer)
    call guessDCF(this)
    call rism_timer_stop(this%cuvpropTimer)
    call timer_stop(TIME_CUVPROP)


    ! 5) Calculate 3D-RISM solution using MDIIS.
    ! If the user has to provide a list of closures, use it only if
    ! this is the first solution (nsolution == 0) or solution
    ! propagation is turned off (ncuvsteps == 0). Otherwise, the
    ! current closure will be the last one in the list.
    if (this%nsolution == 0 .or. this%ncuvsteps == 0) then
       do iclosure = 1, size(this%closureList)
          if (this%verbose >= 1) &
               call rism_report_message("|Switching to "// &
               trim(this%closureList(iclosure))//" closure")
          call rism_timer_stop(this%solventTimer)
          call rism3d_setClosure(this, this%closureList(iclosure))
          call rism_timer_start(this%solventTimer)
          call timer_start(TIME_RXRISM)
          call solve3DRISM(this, ksave, kshow, maxSteps, tolerance(iclosure))
          call timer_stop(TIME_RXRISM)
          ! Increment nsolution and ncuvsteps to ensure the previous
          ! closure solution is used.
          if (iclosure == 1) then
             this%nsolution = this%nsolution + 1
             this%ncuvsteps = this%ncuvsteps + 1
          end if
       end do
       this%nsolution = this%nsolution - 1
       this%ncuvsteps = this%ncuvsteps - 1
    else
       call timer_start(TIME_RXRISM)
       call solve3DRISM(this, ksave, kshow, maxSteps, tolerance(size(tolerance)))
       call timer_stop(TIME_RXRISM)
    end if

    ! 11) Update stored variables.
    call timer_start(TIME_CUVPROP)
    call rism_timer_start(this%cuvpropTimer)
    this%nsolution = this%nsolution + 1
    call updateDCFguessHistory(this)
    call rism_timer_stop(this%cuvpropTimer)
    call timer_stop(TIME_CUVPROP)

    call rism_timer_stop(this%solventTimer)
  end subroutine rism3d_calculateSolution

  !> Calculates the forces on the solute contributed by the solvent according
  !! to 3D-RISM.  Just a wrapper for rism3d_closure_force().
  !! IN:
  !!   this :: rism3d object with computed solution
  !!   ff   :: 3D-RISM forces
  subroutine rism3d_force(this, ff)
    implicit none
    type(rism3d):: this
    _REAL_, intent(out) :: ff(3, this%solute%numAtoms)
    call rism_timer_start(this%forceTimer)
    call timer_start(TIME_FF)
    call rism3d_closure_force(this%closure, ff, this%guv, this%periodicPotential)
    call timer_stop(TIME_FF)
    call rism_timer_stop(this%forceTimer)
    !!!!!!!
    !! - uncomment this to have a proper force check
    !! call rism3d_checkForceNumDeriv(this%closure, ff, this%guv, this%ljTolerance)
    !!!!!!
  end subroutine rism3d_force


  !> Calculate the excess chemical potential for each solvent species
  !! IN:
  !!   this :: rism3d object with computed solution
  !!   o_lr   :: (optional) (default = .true.) Apply asymptotic long range correction
  !! OUT:
  !!    excess chemical potential of solvation for each solvent species
  function rism3d_excessChemicalPotential(this, o_lr) result(excessChemicalPotential)
    implicit none
    type(rism3d), intent(inout) :: this
    logical, optional, intent(in) :: o_lr
    logical :: lr
    _REAL_ :: excessChemicalPotential(this%solvent%numAtomTypes)

    call rism_timer_start(this%excessChemicalPotentialTimer)
    excessChemicalPotential = &
       rism3d_closure_excessChemicalPotential(this%closure, &
       this%huv, this%cuv(:, :, :, :))
    call rism_timer_stop(this%excessChemicalPotentialTimer)
  end function rism3d_excessChemicalPotential

  !> Calculate the total excess chemical potential of solvation
  !! IN:
  !!   this :: rism3d object with computed solution
  !!   o_lr   :: (optional) (default = .true.) Apply asymptotic long range correction
  !! OUT:
  !!    total excess chemical potential of solvation
  function rism3d_excessChemicalPotential_tot(this, o_lr) result(excessChemicalPotential)
    implicit none
    type(rism3d), intent(inout) :: this
    logical, optional, intent(in) :: o_lr
    logical :: lr
    _REAL_ :: excessChemicalPotential
    call rism_timer_start(this%excessChemicalPotentialTimer)

    lr = .true.
    if (present(o_lr)) lr = o_lr
    call rism_timer_stop(this%excessChemicalPotentialTimer)
    excessChemicalPotential = sum(rism3d_excessChemicalPotential(this, o_lr))
  end function rism3d_excessChemicalPotential_tot

  !> Calculate the solvation interaction energy: de = density sum g*u for
  !! each solvent site.  I.e., the direct intection potential energy of
  !! solute and solvent and not the total solvation energy (see solvationEnergy).
  !! IN:
  !!   this :: rism3d object with computed solution
  !! OUT:
  !!    the contribution of each solvent site to the total solvation interaction
  !!    energy [kT]
  function rism3d_solventPotEne(this) result(ene)
    implicit none
    type(rism3d), intent(inout) :: this
    _REAL_ :: ene(this%solvent%numAtomTypes)
    !call rism_timer_start(this%thermoTimer)
    ene = rism3d_closure_solvPotEne(this%closure, this%guv)
    !call rism_timer_stop(this%thermoTimer)
  end function rism3d_solventPotEne


  !> Calculate the total solvation interaction energy: de = density sum g*u for
  !! each solvent site.  I.e., the direct intection potential energy of
  !! solute and solvent and not the total solvation energy (see solvationEnergy).
  !! IN:
  !!   this :: rism3d object with computed solution
  !! OUT:
  !!    the total solvent-solute potential energy [kT]
  function rism3d_solventPotEne_tot(this) result(ene)
    implicit none
    type(rism3d), intent(inout) :: this
    _REAL_ :: ene
    call rism_timer_start(this%thermoTimer)
    ene = sum(rism3d_solventPotEne(this))
    call rism_timer_stop(this%thermoTimer)
  end function rism3d_solventPotEne_tot

  !! Calculating the partial molar volume of solute.
  !! IN:
  !!   this :: rism3d object with computed solution
  !! OUT:
  !!   partial molar volume
  function rism3d_partialMolarVolume(this) result(partialMolarVolume)
    implicit none
    type(rism3d), intent(inout) :: this
    _REAL_ :: partialMolarVolume
    call rism_timer_start(this%thermoTimer)
    partialMolarVolume = rism3d_closure_partialMolarVolume(this%closure, this%cuv(:, :, :, :))
    call rism_timer_stop(this%thermoTimer)
  end function rism3d_partialMolarVolume

  !> Calculating excess number of each solvent type associated with
  !! the solute.
  !! @param[in,out] this rism3d object with computed solution.
  !! @param[in] o_lr (optional) (default = .true.)
  !!                 Apply asymptotic long range correction.
  !! @return Excess number of each solvent type associated with the solute.
  function rism3d_excessParticles(this, o_lr) result(num)
    implicit none
    type(rism3d), intent(inout) :: this
    logical, optional, intent(in) :: o_lr
    logical :: lr
    _REAL_ :: num(this%solvent%numAtomTypes)

    call rism_timer_start(this%thermoTimer)
    num = rism3d_closure_excessParticles(this%closure, this%guv)
    call rism_timer_stop(this%thermoTimer)

  end function rism3d_excessParticles

  !! Calculate the Kirkwood-Buff integral for the solute. This is the
  !! all space integral of huv.
  !!
  !! J. G. Kirkwood; F. P. Buff. J. Chem. Phys. 1951, 19, 774-777
  !! IN:
  !!    this :: rism3d object with computed solution
  !!    o_lr :: (optional) (default = .true.) Apply asymptotic long range
  !!            correction
  !! OUT:
  !!    Kirkwood-Buff integeral for each solvent site
  function rism3d_kirkwoodBuff(this, o_lr) result(kb)
    implicit none
    type(rism3d), intent(inout) :: this
    logical, optional, intent(in) :: o_lr
    _REAL_ :: kb(this%solvent%numAtomTypes)

    call rism_timer_start(this%thermoTimer)
    kb = rism3d_closure_kirkwoodBuff(this%closure, this%guv)
    call rism_timer_stop(this%thermoTimer)
  end function rism3d_kirkwoodBuff

  !! Calculates the direct correlation function integral for the solute. This is the
  !! all space integral of cuv.
  !! IN:
  !!   this :: rism3d object with computed solution
  !! OUT:
  !!    DCF integeral for each solvent site
  function rism3d_DCFintegral(this) result(dcfi)
    implicit none
    type(rism3d), intent(inout) :: this
    _REAL_ :: dcfi(this%solvent%numAtomTypes)
    call rism_timer_start(this%thermoTimer)
    dcfi = rism3d_closure_DCFintegral(this%closure, this%cuv)
    call rism_timer_stop(this%thermoTimer)
  end function rism3d_DCFintegral

!!!!!
  !! DEALLOCATE
!!!!!

!!!!!
  !! deconstructor - frees all memory
!!!!!
  subroutine rism3d_destroy(this)
    use safemem
    implicit none
    type(rism3d) :: this
    call rism_timer_destroy(this%fftTimer)
    call rism_timer_destroy(this%single3DRISMsolutionTimer)
    call rism_timer_destroy(this%solve3DRISMTimer)
    call rism_timer_destroy(this%cuvpropTimer)
    call rism_timer_destroy(this%reorientTimer)
    call rism_timer_destroy(this%resizeTimer)
    call rism_timer_destroy(this%solventTimer)
    call rism_timer_destroy(this%excessChemicalPotentialTimer)
    call rism_timer_destroy(this%forceTimer)
    call rism_timer_destroy(this%thermoTimer)
    call rism_timer_destroy(this%timer)

    call rism3d_solvent_destroy(this%solvent)
    call rism3d_solute_destroy(this%solute)
    call rism3d_potential_destroy(this%potential)
    call rism3d_grid_destroy(this%grid)
    call rism3d_closure_destroy(this%closure)
    call mdiis_destroy(this%mdiis_o)

    if (safemem_dealloc(this%xvva) /= 0) &
         call rism_report_error("RISM3D: failed to deallocate XVVA")
    if (safemem_dealloc(this%cuvWRK) /= 0) &
         call rism_report_error("RISM3D: failed to deallocate CUVWRK")
    if (safemem_dealloc(this%oldcuvChg) /= 0) &
         call rism_report_error("RISM3D: failed to deallocate OLDCUVCHG")
    if (safemem_dealloc(this%oldcuvNoChg) /= 0) &
         call rism_report_error("RISM3D: failed to deallocate OLDCUVNOCHG")
    if (safemem_dealloc(this%cuvresWRK) /= 0) &
         call rism_report_error("RISM3D: failed to deallocate CUVRESWRK")

    if (safemem_dealloc(this%closureList) /= 0) &
         call rism_report_error("RISM3D: failed to deallocate CLOSURELIST")
    if (associated(this%nsolutionChg)) &
         deallocate(this%nsolutionChg)
    if (associated(this%nsolutionNoChg)) &
         deallocate(this%nsolutionNoChg)
    nullify(this%cuv)
    nullify(this%cuvres)
    nullify(this%oldcuv)
    nullify(this%nsolution)

    if (safemem_dealloc(this%guv, o_aligned = .true.) /= 0) &
         call rism_report_error("RISM3D: failed to deallocate GUV")
    if (safemem_dealloc(this%huv, o_aligned = .true.) /= 0) &
         call rism_report_error("RISM3D: failed to deallocate HUV")
    if (safemem_dealloc(this%cuvk, o_aligned = .true.) /= 0) &
         call rism_report_error("RISM3D: failed to deallocate CUVK")
    if (safemem_dealloc(this%electronMap) /= 0) &
         call rism_report_error("RISM3D: failed to deallocate electronMap")
    call rism3d_fft_destroy(this%fft)
    call rism3d_fft_global_finalize()
  end subroutine rism3d_destroy


  !! PRIVATE



  !> Using the current orientation of the solute, define the minimum box size
  !! and resize all associated grids.
  !!
  !! Non-periodic : Either a variable or fixed box size maybe specified
  !!     (this%varbox). If fixed size, then the number of gridpoints provided by
  !!     the user are directly applied but check to ensure they meet the minimum
  !!     requirements of the MPI run, if specified. If variable size the buffer
  !!     is either (a) taken from the user or (b), if buffer==0, determined from
  !!     the ljTolerance cutoff. Grid spacing is taken from the user.
  !!
  !! Periodic : the unit cell is used to determine the number of grid points.
  !!
  !! @param[in] this rism3d object
  subroutine resizeBox(this)
    use constants, only : PI
    use rism_util, only : isprime, lcm, isFactorable, largestPrimeFactor
    implicit none
#if defined(MPI)
    include 'mpif.h'
    integer :: ierr
#endif /*defined(MPI)*/
    type(rism3d), intent(inout) :: this
    integer :: ngr(3)
    integer :: id
    _REAL_ :: boxlen(3)
    integer :: primes(4) = (/2, 3, 5, 7/)
    logical :: cuv_dimension_changed
    integer :: ngr_size

    ! To properly distribute the run, y and z dimension must have a
    ! number of grid points that is a multiple of mpisize.  Thus,
    ! mpisize must be factorizable by small prime numbers.
    if (.not. isFactorable(this%mpisize, primes)) then
       call rism_report_error("(a,10i4)", &
            "Sorry, 3D-RISM requires that the number " &
            //"of processes be a product of ", primes)
    end if

    ! If we have a fixed box size, we simply retain all of the
    ! previously calculated box size values.

    if (this%periodic) then
       !TODO: For periodic case, specifying buffer or box dimensions
       ! is useless, so mention this in user documentation and print a
       ! warning if user attempts to combine periodicity with either.
       ! Also, automatically enable periodicity whenever a cell / box
       ! size is present.

       !TODO: Support both grid spacing or grid dimensions.

       boxlen(:) = this%grid%unitCellLengths(:)

       ! Ensure gridpoints fit in unit cell perfectly by adjusting
       ! grid spacing. Current approach treats user-specified grid
       ! spacing as a maximum spacing.

       ngr(:) = ceiling(boxlen(:) / this%grid%spacing(:))
       this%grid%spacing(:) = boxlen(:) / ngr(:)

       ! Determine if the number of grid points in each dimension
       ! product only has prime factors 2, 3, 5 or 7. If not
       ! increment the number of points (in that dimension) until
       ! this is true.

       ! Make sure that each dimension is divisible by 2 and that the
       ! y- and z-dimensions are divisible by this%mpisize if
       ! this%mpisize > 2.  This former is done for the sake of FFT
       ! libraries.
       ! dac note: this code does not ensure that the y and z dimesions
       !   will still be even after dividing things up among the MPI
       !   threads....
       ! dac note: why do both y and z need to be multiples of mpisize?
       !   is in not just z?

       ngr(:) = ngr(:) + mod(ngr(:), 2)
       if (this%mpisize > 2) then
          do id = 2, 3
             if (mod(ngr(id), this%mpisize) /= 0) then
                ngr(id) = ngr(id) + lcm(this%mpisize, 2) &
                     - mod(ngr(id), lcm(this%mpisize, 2))
             end if
          end do
       end if

       do id = 1, 3
          do while (largestPrimeFactor(ngr(id)) .gt. 9)
             if (this%mpisize > 1 .and. id > 1) then
                ngr(id) = ngr(id) + lcm(this%mpisize, 2)
             else
                ngr(id) = ngr(id) + 2
             end if
          end do
       end do
       this%grid%spacing = boxlen / ngr

       cuv_dimension_changed = .false.
       do id = 1, 3
          ngr_size = merge(ngr(id), ngr(id) / this%mpisize, id /= 3)
          if (ubound(this%cuv, id) /= ngr_size &
               .or. ubound(this%oldcuv, id) /= ngr_size) then
             cuv_dimension_changed = .true.
             exit
          end if
       end do
       if (.not. associated(this%cuv) &
            .or. .not. associated(this%oldcuv) &
            .or. cuv_dimension_changed) then
          call reallocateBox(this, ngr, this%grid%spacing)
       end if

       if (this%potential%cutoff >= this%grid%inscribedSphereRadius) then
          call rism_report_error('(a,f8.2,a)', 'solvcut must be < ', &
               this%grid%inscribedSphereRadius, &
               ', the largest inscribed sphere radius of the unit cell.')
       end if

    end if

  end subroutine resizeBox

  !> Using the current box size and resize all associated grids and
  !! variables.
  !! @param[in,out] this rism3d object.
  !! @param[in] ngr Number of grid points along each axis.
  !! @param[in] grdspc Grid spacing along each axis.
  subroutine reallocateBox(this, ngr, grdspc)
    use constants, only : pi
    use rism3d_fft_c
    use safemem
    implicit none
    type(rism3d) :: this
    integer, intent(in) :: ngr(3)
    _REAL_, intent(in) :: grdspc(3)
    integer :: i, id, irank
    _REAL_ :: memuse
    _REAL_ :: unitCellDimensions(6)

    call rism3d_fft_setgrid(this%grid, ngr, grdspc, &
        this%solvent%numAtomTypes, this%fft_aligned)

    !
    ! 2) allocation
    !
    ! reallocate arrays that require preservation of their contents

    ! I THINK WE CAN GET RID OF THE MPI HERE
#if defined(MPI)
    this%cuvWRK => safemem_realloc(this%cuvWRK, &
         this%grid%localDimsR(1), this%grid%localDimsR(2), this%grid%localDimsR(3), &
         this%solvent%numAtomTypes, this%NVec, .true., .true.)
    if (rism3d_solute_charged(this%solute)) then
       this%oldcuvChg => safemem_realloc(this%oldcuvChg, this%grid%localDimsR(1), this%grid%localDimsR(2), &
            this%grid%localDimsR(3), this%solvent%numAtomTypes, this%ncuvsteps, .true., .true.)
       this%oldcuv => this%oldcuvChg
    else
       this%oldcuvNoChg => safemem_realloc(this%oldcuvNoChg, this%grid%localDimsR(1), this%grid%localDimsR(2), &
            this%grid%localDimsR(3), this%solvent%numAtomTypes, this%ncuvsteps, .true., .true.)
       this%oldcuv => this%oldcuvNoChg
    end if
#else
    this%cuvWRK => safemem_realloc(this%cuvWRK, &
         this%grid%localDimsR(1), this%grid%localDimsR(2), this%grid%localDimsR(3), &
         this%solvent%numAtomTypes, this%NVec, .true., .true.)
    if (rism3d_solute_charged(this%solute)) then
       this%oldcuvChg => safemem_realloc(this%oldcuvChg, this%grid%localDimsR(1), this%grid%localDimsR(2), &
            this%grid%localDimsR(3), this%solvent%numAtomTypes, this%ncuvsteps, .true., .true.)
       this%oldcuv => this%oldcuvChg
    else
       this%oldcuvNoChg => safemem_realloc(this%oldcuvNoChg, this%grid%localDimsR(1), this%grid%localDimsR(2), &
            this%grid%localDimsR(3), this%solvent%numAtomTypes, this%ncuvsteps, .true., .true.)
       this%oldcuv => this%oldcuvNoChg
    end if
#endif /*MPI*/
    ! reallocate arrays that do not require preservation of their contents
    this%guv => safemem_realloc(this%guv, this%grid%totalLocalPointsK, this%solvent%numAtomTypes, &
         o_preserve = .false., o_aligned = .true.)
    this%huv => safemem_realloc(this%huv, this%grid%totalLocalPointsK, this%solvent%numAtomTypes, &
         o_preserve = .false., o_aligned = .true.)
    this%cuvresWRK => safemem_realloc(this%cuvresWRK, this%grid%totalLocalPointsR, this%solvent%numAtomTypes, &
         this%NVec, .false.)
    this%xvva => safemem_realloc(this%xvva, this%grid%waveNumberArraySize * (this%solvent%numAtomTypes)**2, .false.)
    !  dac: only need three dimensions here, since the electronMap
    !  is written to disk as soon as it is calculated
    this%electronMap => safemem_realloc(this%electronMap, &
         this%grid%globalDimsR(1), this%grid%globalDimsR(2), &
         this%grid%globalDimsR(3), o_preserve = .false.)

    call rism3d_fft_destroy(this%fft)
    call rism3d_fft_new(this%fft, &
         this%fftw_planner, this%fftw_localtrans, this%fft_aligned, &
         this%grid, &
         this%guv, this%huv)

    ! updated pointers
    call mdiis_resize(this%mdiis_o, this%cuvWRK, this%cuvresWRK, &
         this%grid%totalLocalPointsR * this%solvent%numAtomTypes, this%nvec)
    this%cuv => this%cuvWRK(:, :, :, :, mdiis_getWorkVector(this%mdiis_o))
    this%cuvres => this%cuvresWRK(:, :, mdiis_getWorkVector(this%mdiis_o))


    ! If we have a previous solution with no charges, then this%cuv
    ! will likely have the wrong previous solution, whether or not we
    ! now have charges set.  The first solution in this%oldcuv will
    ! have the last solution with the current charge setting, so we
    ! copy that over.

    if (this%nsolutionNoChg > 0) then
       if (all(ubound(this%oldcuv(:,:,:,:,1)) .eq. ubound(this%cuv))) then
          call dcopy(product(ubound(this%cuv)), this%oldcuv, 1,this%cuv, 1)
       else
          call rism_report_error('(a,l,a,5(i),a,4(i))', &
               'Should not get here. Attempting to copy oldcuv to cuv failed:'//NEW_LINE('A')//&
               'Charged : ',this%solute%charged,NEW_LINE('A')//&
               'ubound(oldcuv) : ', ubound(this%oldcuv), NEW_LINE('A')//&
               'ubound(cuv) : ', ubound(this%cuv))
      end if
    end if
    
    !
    ! 3) the remaining variables are handled by rism_setup_wavevector, interpolateSolventSusceptibility
    !
    call interpolateSolventSusceptibility(this, this%solvent%xvv, this%xvva)
  end subroutine reallocateBox

  !> Prints the maximum amount of memory allocated at any one time so
  !! far in the run.
  subroutine rism3d_max_memory(this)
    use safemem
    implicit none
#ifdef MPI
    include "mpif.h"
#endif /*MPI*/
    type(rism3d) :: this
    integer * 8 :: memstats(10), tmemstats(10)
    integer :: err, irank, outunit
    outunit = rism_report_getMUnit()
    memstats = memStatus()
#ifdef MPI
#  ifdef USE_MPI_IN_PLACE
    if (this%mpirank == 0) then
       call MPI_REDUCE(MPI_IN_PLACE, memstats, ubound(memstats, 1), MPI_INTEGER8, &
            MPI_SUM, 0,this%mpicomm, err)
    else
       call MPI_REDUCE(memstats, memstats, ubound(memstats, 1), MPI_INTEGER8, &
            MPI_SUM, 0,this%mpicomm, err)
    end if
#  else /*USE_MPI_IN_PLACE*/
    call MPI_REDUCE(memstats, tmemstats, ubound(memstats, 1), MPI_INTEGER8, &
         MPI_SUM, 0,this%mpicomm, err)
    memstats = tmemstats
#  endif /*USE_MPI_IN_PLACE*/
    if (err/=0) call rism_report_warn("RISM_MAX_MEMORY: MPI_REDUCE failed.")
#endif
    if (this%mpirank == 0) then
       write(outunit, '(a)')
       write(outunit, '(a)') "|3D-RISM memory allocation summary"
       write(outunit, '(a)') "|Type          Maximum"
       write(outunit, '(a,f12.5,a)') "|Integer  ", &
            dble(memstats(1))/BYTES_PER_GB, " GB"
       write(outunit, '(a,f12.5,a)') "|Real     ", &
            dble(memstats(2))/BYTES_PER_GB, " GB"
       write(outunit, '(a,f12.5,a)') "|Logical  ", &
            dble(memstats(3))/BYTES_PER_GB, " GB"
       write(outunit, '(a,f12.5,a)') "|Character", &
            dble(memstats(4))/BYTES_PER_GB, " GB"
       write(outunit, '(a)') "|------------------------"
       write(outunit, '(a,f12.5,a)') "|Total    ", &
            dble(memstats(5))/BYTES_PER_GB, " GB"
    end if
  end subroutine rism3d_max_memory


  !> Interpolate the solvent-solvent susceptibility, solved on the
  !! 1D-RISM grid, to the 3D-RISM grid.
  !! @param[in,out] this rism3d object.
  !! @param[in] xvv 1D-RISM Xvv or Xvv_dT data.
  !! @param[out] xvva Interpolated result.
  subroutine interpolateSolventSusceptibility(this, xvv, xvva)
    use rism_util, only : polynomialInterpolation
    implicit none
    type(rism3d), intent(inout) :: this
    _REAL_, intent(in) :: xvv(:, :, :)
    _REAL_, intent(out) :: xvva(:)
    integer :: iwn, igk, igk1, iv1, iv2
    _REAL_ :: err
    !> Maximum number of points to interpolate.
    integer :: maxPointsToInterp
    parameter (maxPointsToInterp = 5)

    ! Checking R-grid size.
    if (this%grid%waveNumbers(this%grid%waveNumberArraySize) > this%solvent%waveNumbers(this%solvent%numRDFpoints)) then
       call rism_report_error('(a,1pe16.8,a,1pe16.8)', &
            'DISTVV: bulk solvent Kmax=', this%solvent%waveNumbers(this%solvent%numRDFpoints), &
            'insufficient for 3D-grid Kmax=', this%grid%waveNumbers(this%grid%waveNumberArraySize))
    else if (maxPointsToInterp > this%solvent%numRDFpoints) then
       call rism_report_error('(a,i7,a,i7)', &
            'DISTVV: bulk solvent grid size Nr=', this%solvent%numRDFpoints, &
            'insufficient for interpolation maxPointsToInterp=', maxPointsToInterp)
    end if

    ! Interpolate Xvv(k) on 1D-RISM grid to 3D-RISM grid.
    ! Interpolation is performed about the 1D-RISM wave number just
    ! larger than the current 3D-RISM wave number, with a point range
    ! of +/- maxPointsToInterp / 2.
    do iwn = 1, this%grid%waveNumberArraySize
       ! Find the smallest 1D-RISM wave number just larger than the
       ! current 3D-RISM wave number.  The range starts at
       ! this point - maxPointsToInterp/2 and goes up to + maxPointsToInterp/2.
       do igk = 1, this%solvent%numRDFpoints - maxPointsToInterp + 1
          igk1 = igk
          if (this%solvent%waveNumbers(igk1 + maxPointsToInterp/2) > this%grid%waveNumbers(iwn)) then
             exit
          end if
       end do
       ! Interpolate from 1D-RISM to 3D-RISM grids about the midpoint
       ! +/- maxPointsToInterp/2.
       do iv2 = 1, this%solvent%numAtomTypes
          do iv1 = 1, this%solvent%numAtomTypes
             call polynomialInterpolation( &
                  this%solvent%waveNumbers(igk1:igk1 + maxPointsToInterp), &
                  xvv(igk1:igk1 + maxPointsToInterp, iv1, iv2), maxPointsToInterp, &
                  this%grid%waveNumbers(iwn), &
                  xvva(iwn + (iv1 - 1) * this%grid%waveNumberArraySize &
                  + (iv2 - 1) * this%grid%waveNumberArraySize * this%solvent%numAtomTypes), &
                  err)
          end do
       end do
    end do
  end subroutine interpolateSolventSusceptibility

  !!!!
  !! Subroutines to find the iterative 3D-RISM solution.
  !!!!

  !> Main driver for the 3D-RISM solver.
  !! Makes an initial guess of the direct correlation function and
  !! then solve the RISM and closure relations until either the
  !! solution converges or the maximum of steps is reached.
  !! @param[in,out] this rism3d object.
  !! @param[in] ksave Save itermediate results every ksave interations
  !!  (0 means no saves).
  !! @param[in] kshow Print parameter for relaxation steps every kshow
  !!  iteration (0 means no saves).
  !! @param[in] maxSteps Maximum number of rism relaxation steps.
  !! @param[in] tolerance Tolerance in.
  subroutine solve3DRISM(this, ksave, kshow, maxSteps, tolerance)
    use mdiis_c
    use rism3d_restart
    implicit none
#include "def_time.h"
#if defined(MPI)
    include 'mpif.h'
#endif /*defined(MPI)*/
    type(rism3d), intent(inout) :: this
    integer, intent(in) :: ksave, kshow, maxSteps
    _REAL_, intent(in) :: tolerance
    character(72) :: cuvsav = 'rism.csv', guvfile
    integer :: guv_local = 77

    integer :: iatv, igx, igy, igz
    logical :: found, converged = .false.
    integer :: ig, igr, iv, iv2, istep
    _REAL_ :: residual = 0

    ! Absolute first time in solve3DRISM.
    logical, save :: first = .true.

    ! MPI rank counter.
    integer :: irank
    ! iostat
    integer :: stat
    integer :: ientry, nentry
    ! MPI error.
    logical :: ierr

    call rism_timer_start(this%solve3DRISMTimer)

    if (this%verbose >= 1 .and. size(this%closureList) > 1) &
         call rism_report_message("|Using "// &
         trim(rism3d_closure_type(this%closure))//" closure")

    ! Make initial guess for DCF.
    this%cuvres = 0
#ifdef MPI
#else
    if (this%mpirank == 0) then
       inquire (file = cuvsav, exist = found)
       if (found .and. first .and. ksave /= 0) then
          write(6,*)'| reading saved Cuv file:  ', cuvsav
          call readRestartFile(cuvsav, this%cuv(:, :, :, :), &
               this%grid%totalLocalPointsR, this%solvent%numAtomTypes)
       else
#endif /*MPI*/

          if (this%nsolution == 0 .or. this%ncuvsteps == 0) then
             ! Default initial guess for DCF is zero everywhere.
             this%cuv(:,:,:,:) = 0.d0
          end if
#ifdef MPI
#else
       end if
    end if
#endif /*MPI*/

    ! Solve 3D-RISM for the current solute-solvent system.
    !
    ! This is done by first using the DCF guess above, the calculated
    ! potentials, and the 1D-RISM solvent-solvent susceptibility to
    ! solve the 3D-RISM equation for the TCF. These values are then
    ! used in the bridge function to obtain a new solution for TCF.
    ! The difference between the bridge function TCF and the 3D-RISM
    ! TCF is the residual, which is used to create a new guess for the
    ! DCF.
    !
    ! The process repeats until the residual is minimized to a desired
    ! amount, at which point the solution is considered converged.
    !
    ! MDIIS is used to increase the rate of convergence by combining
    ! knowledge of previous guesses of the DCF with the current TCF
    ! residual to give an improved guess for the DCF.

    call mdiis_reset(this%mdiis_o)
    this%cuv => this%cuvWRK(:, :, :, :, mdiis_getWorkVector(this%mdiis_o))
    this%cuvres => this%cuvresWRK(:, :, mdiis_getWorkVector(this%mdiis_o))

    call timer_start(TIME_R1RISM)
    do istep = 1, maxSteps
       !  -----------------------------------------------------------------
       ! One iteration of 3D-RISM and closure relation, advancing w/ mdiis.
       !  -----------------------------------------------------------------
       call single3DRISMsolution(this, residual, converged, tolerance, &
           this%periodic)

       ! Showing selected and last relaxation steps.
       if (kshow /= 0 .and. this%mpirank == 0 .and. this%verbose >= 2) then
          if (converged .or. mod(istep, kshow) == 0 .or. &
               ksave > 0 .and. mod(istep, max(ksave, 1)) == 0) then
             call rism_report_message('(a,i5,5x,a,1pg10.3,5x,a,i3)', &
                  ' Step=', istep, 'Resid=', residual, 'IS=', &
                  getCurrentNVec(this%mdiis_o))
             call rism_report_flush()
          end if
       end if

       ! Exiting relaxation loop on convergence.
       if (converged) exit
    end do

    if (.not. converged) then
       call rism_report_error('(a,i5)', &
          'RXRISM: reached limit # of relaxation steps: ', maxSteps)
    end if
    call timer_stop(TIME_R1RISM)

    first = .false.
    if (this%mpirank == 0 .and. this%verbose >= 1) then
       call rism_report_message('(a,i5,a)', &
           "|RXRISM converged in ", istep, " steps")
    end if
    call rism_timer_stop(this%solve3DRISMTimer)
    return
  end subroutine solve3DRISM


  !> One relaxation step for the UV-RISM equation with the HNC closure,
  !! Guv(r) = exp(-Uuv(r) + Tuv(r) - DelHv0) + DelHv0
  !! Cuv(r) = Guv(r) - 1 - Tvv(r)
  !! Huv(k) = Cuv(k) * (Wvv(k) + Density * Hvv(k))
  !! TuvRes(r) = Huv(r) - Guv(r) - 1
  !! @param[in,out] this A rism3d object.
  !! @param[in,out] residual ???
  !! @param[in,out] converged Returns true if the solution has converged.
  !! @param[in] tolerance Target residual tolerance for convergence.
  subroutine single3DRISMsolution(this, residual, converged, tolerance, &
      periodic )

    use rism3d_fft_c
    use constants, only : PI, FOURPI
    implicit none
#include "def_time.h"
#if defined(MPI)
    include 'mpif.h'
#endif /*defined(MPI)*/
    type(rism3d), intent(inout) :: this
    logical, intent(inout) :: converged
    _REAL_, intent(inout) :: residual
    _REAL_, intent(in) :: tolerance
    logical, intent(in) :: periodic
    integer :: iis
    _REAL_ :: earg, tuv0, tvvr
    integer :: istep

    integer ::  ig1, iga, iv, iv1, iv2, igx, igy, igz, igk
#ifdef FFW_THREADS
    integer :: nthreads, totthreads
    integer, external :: OMP_get_max_threads, OMP_get_num_threads
    logical, external :: OMP_get_dynamic, OMP_get_nested
#endif
    integer :: ierr, irank
    call rism_timer_start(this%single3DRISMsolutionTimer)

    ! --------------------------------------------------------------
    ! Subtract short-range part from Cuv(r) (if not periodic);
    ! Cuv(r) is then loaded into the guv array.
    ! --------------------------------------------------------------

#if defined(MPI)
    do iv = 1, this%solvent%numAtomTypes
       do igz = 1, this%grid%localDimsR(3)
          do igy = 1, this%grid%localDimsR(2)
                do igx = 1, this%grid%localDimsR(1)
                   igk = igx + (igy-1) * (this%grid%localDimsR(1) + 2) &
                        + (igz-1) * this%grid%localDimsR(2) * (this%grid%localDimsR(1) + 2)
                   this%guv(igk, iv) = this%cuv(igx, igy, igz, iv)
                end do
             ! Zero out extra space.
             igk = this%grid%localDimsR(1) + 1 + (igy-1) * (this%grid%localDimsR(1) + 2) &
                  + (igz-1) * this%grid%localDimsR(2) * (this%grid%localDimsR(1) + 2)
             this%guv(igk:igk + 1, iv) = 0.d0
          end do
       end do
    end do
#else
!$omp parallel do private(iv,igx,igy,igz,ig1)  &
!$omp&        num_threads(this%solvent%numAtomTypes)
    do iv = 1, this%solvent%numAtomTypes
          do igz = 1, this%grid%localDimsR(3)
             do igy = 1, this%grid%localDimsR(2)
                do igx = 1, this%grid%localDimsR(1)
                   ig1 = igx + (igy-1) * this%grid%localDimsR(1) &
                             + (igz-1) * this%grid%localDimsR(2) &
                                       * this%grid%localDimsR(1)
                   this%guv(ig1, iv) = this%cuv(igx, igy, igz, iv)
                end do
             end do
          end do
       ! Zero out extra space.
       this%guv(this%grid%totalLocalPointsR + 1:this%grid%totalLocalPointsK, iv) = 0.d0
    end do
!$omp end parallel do
#endif /*defined(MPI)*/

    ! --------------------------------------------------------------
    ! [Short-range part of] Cuv(r) FFT>K.
    ! --------------------------------------------------------------
    call timer_start(TIME_RISMFFT)
    call rism_timer_start(this%fftTimer)
#if defined(MPI)
    call  rism3d_fft_fwd(this%fft, this%guv)
    this%guv(2:this%grid%totalLocalPointsK:2, :) = &
         -this%guv(2:this%grid%totalLocalPointsK:2, :)
#else
    call  rism3d_fft_fwd(this%fft, this%guv)
#endif /*defined(MPI)*/
    call rism_timer_stop(this%fftTimer)
    call timer_stop(TIME_RISMFFT)

    ! --------------------------------------------------------------
    ! Huv(k) by RISM.
    ! --------------------------------------------------------------
!$omp parallel do private(iv1,iv2,ig1,iga)  &
!$omp&        num_threads(this%solvent%numAtomTypes)
    do iv1 = 1, this%solvent%numAtomTypes
       do ig1 = 1, this%grid%totalLocalPointsK
          this%huv(ig1, iv1) = 0d0
          iga = this%grid%waveVectorWaveNumberMap((ig1 + 1) / 2)
          do iv2 = 1, this%solvent%numAtomTypes
             this%huv(ig1, iv1) = this%huv(ig1, iv1) &
                  + this%guv(ig1, iv2) * this%xvva(iga + (iv2 - 1) &
                     * this%grid%waveNumberArraySize &
                  + (iv1 - 1) * this%grid%waveNumberArraySize &
                     * this%solvent%numAtomTypes)
          end do
       end do
    end do
!$omp end parallel do

    ! ---------------------------------------------------------------
    ! Remove the background charge effect from periodic calculations.
    ! ---------------------------------------------------------------
    if (periodic) then
         if (this%mpirank == 0 .and. this%solute%charged .and. this%solvent%ionic ) then
           do iv = 1,this%solvent%numAtomTypes
                this%huv(1,iv) = this%huv(1,iv) - this%potential%phineut(iv)
           end do
         endif
    end if ! periodic

    ! --------------------------------------------------------------
    ! Short-range part of Huv(k) FFT>R.
    ! --------------------------------------------------------------
    call timer_start(TIME_RISMFFT)
    call rism_timer_start(this%fftTimer)
#if defined(MPI)
    this%huv(2:this%grid%totalLocalPointsK:2, :) = &
         -this%huv(2:this%grid%totalLocalPointsK:2, :)
    call  rism3d_fft_bwd(this%fft, this%huv)
#else
    call  rism3d_fft_bwd(this%fft, this%huv)
#endif /*defined(MPI)*/
    call rism_timer_stop(this%fftTimer)
    call timer_stop(TIME_RISMFFT)

    ! --------------------------------------------------------------
    ! Solve the closure for the RDF.
    ! --------------------------------------------------------------
    call rism3d_closure_guv(this%closure, this%guv, this%huv, this%cuv)

    ! --------------------------------------------------------------
    ! Calculate TCF residual for use in estimating DCF residual.
    ! --------------------------------------------------------------
    this%cuvres(:, :) = 0
!$omp parallel do private(iv,igx,igy,igz,ig1,igk)  &
!$omp&        num_threads(this%solvent%numAtomTypes)
    do iv = 1, this%solvent%numAtomTypes
       do igz = 1, this%grid%localDimsR(3)
          do igy = 1, this%grid%localDimsR(2)
             do igx = 1, this%grid%localDimsR(1)
                ig1 = igx + (igy - 1) * this%grid%localDimsR(1) + &
                     (igz - 1) * this%grid%localDimsR(2) * this%grid%localDimsR(1)
#if defined(MPI)
                igk = igx + (igy - 1) * (this%grid%localDimsR(1) + 2) &
                     + (igz - 1) * this%grid%localDimsR(2) * (this%grid%localDimsR(1) + 2)
#else
                igk = ig1
#endif /*defined(MPI)*/
                this%cuvres(ig1, iv) = this%guv(igk, iv) - 1d0 - this%huv(igk, iv)
             end do
          end do
       end do
    end do
!$omp end parallel do

    ! --------------------------------------------------------------
    ! MDIIS
    ! --------------------------------------------------------------
    call timer_start(TIME_MDIIS)
    call mdiis_advance(this%mdiis_o, residual, converged, tolerance)
    this%cuv => this%cuvWRK(:, :, :, :, mdiis_getWorkVector(this%mdiis_o))
    this%cuvres => this%cuvresWRK(:, :, mdiis_getWorkVector(this%mdiis_o))
    call timer_stop(TIME_MDIIS)
    call rism_timer_stop(this%single3DRISMsolutionTimer)

  end subroutine single3DRISMsolution

  ! PROPAGATE PREVIOUS SOLUTIONS

  !> Calculates a new initial guess for CUV based on the final solutions
  !! from previous timesteps.  The maximum number of previous time
  !! steps to use is provided by the user in ncuvsteps.  However, if
  !! there are not enough previous timesteps only nsolution previous
  !! timesteps will be used.
  !!
  !! See section 2.3.1 and eqs. 8-13 of doi:10.1021/ct900460m for
  !! details.
  !! @param[in] this rism3d object.
  subroutine guessDCF(this)
    implicit none
    type(rism3d) :: this
    integer :: iv, n
    n = this%grid%totalLocalPointsR * this%solvent%numAtomTypes
    if (this%ncuvsteps >= 5 .and. this%nsolution >= 5) then
       call dscal(n, 5d0, this%cuv(:, :, :, :), 1)
       call daxpy(n, -10d0, this%oldcuv(:, :, :, :, 2), 1, this%cuv(:, :, :, :), 1)
       call daxpy(n, 10d0, this%oldcuv(:, :, :, :, 3), 1, this%cuv(:, :, :, :), 1)
       call daxpy(n, -5d0, this%oldcuv(:, :, :, :, 4), 1, this%cuv(:, :, :, :), 1)
       call daxpy(n, 1d0, this%oldcuv(:, :, :, :, 5), 1, this%cuv(:, :, :, :), 1)
    else if (this%ncuvsteps >= 4 .and. this%nsolution >= 4) then
       call dscal(n, 4d0, this%cuv(:, :, :, :), 1)
       call daxpy(n, -6d0, this%oldcuv(:, :, :, :, 2), 1, this%cuv(:, :, :, :), 1)
       call daxpy(n, 4d0, this%oldcuv(:, :, :, :, 3), 1, this%cuv(:, :, :, :), 1)
       call daxpy(n, -1d0, this%oldcuv(:, :, :, :, 4), 1, this%cuv(:, :, :, :), 1)
    else if (this%ncuvsteps >= 3 .and. this%nsolution >= 3) then
       call dscal(n, 3d0, this%cuv(:, :, :, :), 1)
       call daxpy(n, -1d0, this%oldcuv(:, :, :, :, 2), 1, this%cuv(:, :, :, :), 1)
       call daxpy(n, 1d0, this%oldcuv(:, :, :, :, 3), 1, this%cuv(:, :, :, :), 1)
    else if (this%ncuvsteps >= 2 .and. this%nsolution >= 2) then
       call dscal(n, 2d0, this%cuv(:, :, :, :), 1)
       call daxpy(n, -1d0, this%oldcuv(:, :, :, :, 2), 1, this%cuv(:, :, :, :), 1)
    else if (this%ncuvsteps == 0) then
       this%cuv(:, :, :, :) = 0
    end if
  end subroutine guessDCF


  !> Updates the values in the this%oldcuv queue.  The oldest value (the
  !! ncuvstep index) is pushed out, the remainder of the data is
  !! shifted and the newest solution is placed in the first index.
  !! @param[in] this rism3d object.
  subroutine updateDCFguessHistory(this)
    implicit none
    type(rism3d) :: this
    integer :: istep, iv
#ifdef RISM_DEBUG
    write(0, *) "DCF_GUESS_HISTORY_UPDATE"; call flush(0)
#endif /*RISM_DEBUG*/
    if (this%ncuvsteps == 0) return
    do istep = min(this%ncuvsteps, this%nsolution), 2, -1
       call dcopy(this%grid%totalLocalPointsR * this%solvent%numAtomTypes, this%oldcuv(:, :, :, :, istep-1), 1, &
            this%oldcuv(:, :, :, :, istep), 1)
    end do
    call dcopy(this%grid%totalLocalPointsR * this%solvent%numAtomTypes, this%cuv(:, :, :, :), 1, &
         this%oldcuv(:, :, :, :, 1), 1)
  end subroutine updateDCFguessHistory

  !> Create an electron density map from a 3D solute-solvent RDF by
  !! smearing the 3D RDF with a 1D solvent electron denisty RDF.
  !! TODO: Currently only water oxygen is supported for electron
  !! smearing.
  !! @param[in] this rism3d object.
  !! @param[in] electronRDF Solvent 1D electron density map.
  !! @param[in] totalSolventElectrons Total electrons in solvent. Ex.: for water, Z = 10.
  !! @param[out] electronMap Resulting smeared electron density map.
  subroutine createElectronDensityMap(this, iv, electronRDF, &
       electronRDFGridSpacing, totalSolventElectrons, density, electronMap)
    implicit none
    type(rism3d), intent(in) :: this
    integer, intent(in) :: iv
    _REAL_, intent(in) :: electronRDF(:)
    _REAL_, intent(in) :: electronRDFGridSpacing
    integer, intent(in) :: totalSolventElectrons
    _REAL_, intent(in) :: density
    _REAL_, intent(out) :: electronMap(:,:,:)

    integer :: numSmearGridPoints(3)
    integer :: igx, igy, igz, igk, igxCenter, igyCenter, igzCenter
    integer :: igCenter
    _REAL_ :: rx(3), ry(3), rz(3), rxCenter(3), ryCenter(3), rzCenter(3)
    _REAL_ :: distance
    _REAL_ :: numElectronsAtGridCenter
    integer :: numUnitCells(3)

    _REAL_ :: electronRDFSum
    integer :: centerGridIndex(3), smearGridIndex(3)
    _REAL_ :: centerGridPoint(3), smearGridPoint(3)
    _REAL_ :: distanceVector(3)
    integer :: rdfIndex

    !TODO: Make this user defined?
    _REAL_, parameter :: cutoff = 2.0
    ! Value near zero.
    _REAL_, parameter :: nearZero = 1E-10

    electronMap(:,:,:) = 0

    ! Number of grid points to smear in each direction.
    numSmearGridPoints = floor(cutoff / this%grid%spacing)

    ! Determine how many electrons to place in the center grid point.
    do igz = -numSmearGridPoints(3), numSmearGridPoints(3)
       rz = igz * this%grid%voxelVectorsR(3, :)
       do igy = -numSmearGridPoints(2), numSmearGridPoints(2)
          ry = igy * this%grid%voxelVectorsR(2, :)
          do igx = -numSmearGridPoints(1), numSmearGridPoints(1)
             rx = igx * this%grid%voxelVectorsR(1, :)

             if (igx == 0 .and. igy == 0 .and. igz == 0) cycle

             distance = sqrt(dot_product((/ rx, ry, rz /), (/ rx, ry, rz /)))
             rdfIndex = ceiling(distance / electronRDFGridSpacing)
             ! If the rdfIndex falls outside the range then assume
             ! there are no electron outside, which is reasonable for
             ! an RDF with a 4 Angstrom maximum distance.
             if (rdfIndex <= size(electronRDF)) then
                electronRDFSum = electronRDFSum + &
                     electronRDF(rdfIndex) * this%grid%voxelVolume
             end if
          end do
       end do
    end do
    ! Sum contains all contribution from grid points within the cutoff
    ! EXCEPT the center grid point.
    numElectronsAtGridCenter = totalSolventElectrons - electronRDFSum

!$omp parallel do shared(this, density, electronMap, numSmearGridPoints, numElectronsAtGridCenter)
    do igzCenter = 0, this%grid%globalDimsR(3) - 1
       rzCenter = igzCenter * this%grid%voxelVectorsR(3, :)
       do igyCenter = 0, this%grid%globalDimsR(2) - 1
          ryCenter = igyCenter * this%grid%voxelVectorsR(2, :)
          do igxCenter = 0, this%grid%globalDimsR(1) - 1
             rxCenter = igxCenter * this%grid%voxelVectorsR(1, :)

             igCenter = 1 + igxCenter + igyCenter * this%grid%globalDimsR(1) + &
                  igzCenter * this%grid%globalDimsR(2) * this%grid%globalDimsR(1)

             centerGridIndex = (/ igxCenter, igyCenter, igzCenter /)
             centerGridPoint = rxCenter + ryCenter + rzCenter

             if (this%guv(igCenter, iv) > nearZero) then
                ! Center grid.
!$omp critical
                electronMap(igxCenter + 1, igyCenter + 1, igzCenter + 1) = &
                     electronMap(igxCenter + 1, igyCenter + 1, igzCenter + 1) + &
                     numElectronsAtGridCenter * &
                     this%guv(igCenter, iv) * density
!$omp end critical
                do igz = igzCenter - numSmearGridPoints(3), igzCenter + numSmearGridPoints(3)
                   rz = igz * this%grid%voxelVectorsR(3, :)
                   do igy = igyCenter - numSmearGridPoints(2), igyCenter + numSmearGridPoints(2)
                      ry = igy * this%grid%voxelVectorsR(2, :)
                      do igx = igxCenter - numSmearGridPoints(1), igxCenter + numSmearGridPoints(1)
                         rx = igx * this%grid%voxelVectorsR(1, :)

                         smearGridIndex = (/ igx, igy, igz /)
                         smearGridPoint = rx + ry + rz

                         distanceVector = smearGridPoint - centerGridPoint
                         distance = sqrt(dot_product(distanceVector, distanceVector))
                         if (distance .le. cutoff) then
                            ! Outside of box?
                            if (any(smearGridIndex < 0) .or. any(smearGridIndex >= this%grid%globalDimsR)) then
                               if (this%periodic) then
                                  ! Jump to grid image inside box.
                                  numUnitCells = floor(real(smearGridIndex) / this%grid%globalDimsR)
                                  smearGridIndex = smearGridIndex - numUnitCells * this%grid%globalDimsR
                               else
                                  cycle
                               end if
                            ! Skip center grid point.
                            else if (all(smearGridIndex == centerGridIndex)) then
                               cycle
                            end if

                            rdfIndex = ceiling(distance / electronRDFGridSpacing)
                            if (rdfIndex .le. size(electronRDF)) then
!$omp critical
                               smearGridIndex = smearGridIndex + 1
                               electronMap(smearGridIndex(1), smearGridIndex(2), smearGridIndex(3)) = &
                                    electronMap(smearGridIndex(1), smearGridIndex(2), smearGridIndex(3)) &
                                    + electronRDF(rdfIndex) * this%grid%voxelVolume &
                                    * this%guv(igCenter, iv) * density
!$omp end critical
                            end if
                         end if
                      end do
                   end do
                end do
             end if
          end do
       end do
    end do
!$omp end parallel do
  end subroutine createElectronDensityMap

end module rism3d_c
